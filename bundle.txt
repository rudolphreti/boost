package.json

{
  "name": "boost-ui",
  "version": "1.0.0",
  "type": "module",
  "main": "main.js",
  "scripts": {
    "start": "electron ."
  },
  "devDependencies": {
    "electron": "^39.2.7"
  },
  "dependencies": {
    "node-poweredup": "^10.0.0"
  }
}

-----------------

main.js

import { app, BrowserWindow, ipcMain } from "electron";
import { PoweredUP } from "node-poweredup";

const LEFT_PORT = "A";
const RIGHT_PORT = "B";

let win;
let hub = null;
let leftMotor = null;
let rightMotor = null;

let lastL = 0;
let lastR = 0;

function clamp100(x) {
  return Math.max(-100, Math.min(100, x));
}

function send(l, r) {
  l = Math.trunc(clamp100(l));
  r = Math.trunc(clamp100(r));

  if (leftMotor && l !== lastL) {
    leftMotor.setPower(l);
    lastL = l;
  }
  if (rightMotor && r !== lastR) {
    rightMotor.setPower(r);
    lastR = r;
  }
}

async function connectBoost() {
  const poweredUP = new PoweredUP();

  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => reject(new Error("Hub not found")), 15000);

    poweredUP.on("discover", async (h) => {
      try {
        clearTimeout(timeout);
        hub = h;

        if (poweredUP.stopScanning) poweredUP.stopScanning();

        await hub.connect();
        leftMotor = await hub.waitForDeviceAtPort(LEFT_PORT);
        rightMotor = await hub.waitForDeviceAtPort(RIGHT_PORT);

        send(0, 0);
        resolve();
      } catch (e) {
        reject(e);
      }
    });

    poweredUP.scan();
  });
}

async function disconnectBoost() {
  try {
    send(0, 0);
    leftMotor?.brake();
    rightMotor?.brake();
  } catch {}
  try {
    await hub?.disconnect();
  } catch {}
  hub = null;
  leftMotor = null;
  rightMotor = null;
}

function createWindow() {
  win = new BrowserWindow({
    width: 520,
    height: 420,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false
    }
  });

  win.loadFile("index.html");

  win.on("close", async (e) => {
    e.preventDefault();
    await disconnectBoost();
    win.destroy();
  });
}

app.whenReady().then(createWindow);

ipcMain.handle("boost:connect", async () => {
  await connectBoost();
  return { ok: true };
});

ipcMain.handle("boost:disconnect", async () => {
  await disconnectBoost();
  return { ok: true };
});

ipcMain.handle("boost:drive", async (_evt, payload) => {
  send(payload.left, payload.right);
  return { ok: true };
});

-----------------

index.html

<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>LEGO BOOST Control</title>
  <style>
    body { font-family: Arial; padding: 16px; }
    .row { margin: 10px 0; }
    button { padding: 8px 14px; margin-right: 6px; }
    input[type=range] { width: 220px; }
    .mono { font-family: Consolas, monospace; }
  </style>
</head>
<body>

<h2>LEGO BOOST – sterowanie</h2>

<div class="row">
  <button id="connect">Połącz</button>
  <button id="disconnect">Rozłącz</button>
  <button id="stop">STOP</button>
</div>

<div class="row">
  Prędkość:
  <input id="speed" type="range" min="5" max="80" value="25">
  <span id="speedVal" class="mono">25</span>
</div>

<div class="row">
  Skręt:
  <input id="steer" type="range" min="0" max="100" value="60">
  <span id="steerVal" class="mono">0.60</span>
</div>

<div class="row mono">
  Status: <span id="status">rozłączony</span>
</div>

<p>
Sterowanie: ↑ ↓ ← → (keydown/keyup)<br>
Spacja = STOP
</p>

<script src="renderer.js"></script>
</body>
</html>

-----------------

renderer.js

const { ipcRenderer } = window.require("electron");

const statusEl = document.getElementById("status");
const speedEl = document.getElementById("speed");
const speedVal = document.getElementById("speedVal");
const steerEl = document.getElementById("steer");
const steerVal = document.getElementById("steerVal");

let connected = false;
let up=false, down=false, left=false, right=false;
let lastL=0, lastR=0;

function clamp100(x) {
  return Math.max(-100, Math.min(100, x));
}

function compute() {
  const speed = Number(speedEl.value);
  const steer = Number(steerEl.value) / 100;

  let throttle = up ? 1 : down ? -1 : 0;
  let s = left ? -1 : right ? 1 : 0;

  // Turn-in-place when no throttle (so left/right works immediately)
  if (throttle === 0) {
    if (s === 0) return { left: 0, right: 0 };
    const rot = Math.max(10, Math.trunc(speed)); // rotation power based on speed slider
    return { left: -s * rot, right: s * rot };
  }

  const base = throttle * speed;
  return {
    left: clamp100(base * (1 - s * steer)),
    right: clamp100(base * (1 + s * steer))
  };
}


async function send(l, r) {
  l = Math.trunc(l);
  r = Math.trunc(r);
  if (!connected) return;
  if (l === lastL && r === lastR) return;
  lastL = l; lastR = r;
  await ipcRenderer.invoke("boost:drive", { left: l, right: r });
}

function apply() {
  const t = compute();
  send(t.left, t.right);
}

document.getElementById("connect").onclick = async () => {
  statusEl.textContent = "łączenie...";
  await ipcRenderer.invoke("boost:connect");
  connected = true;
  statusEl.textContent = "połączony";
};

document.getElementById("disconnect").onclick = async () => {
  await ipcRenderer.invoke("boost:disconnect");
  connected = false;
  send(0,0);
  statusEl.textContent = "rozłączony";
};

document.getElementById("stop").onclick = () => {
  up=down=left=right=false;
  send(0,0);
};

speedEl.oninput = () => {
  speedVal.textContent = speedEl.value;
  apply();
};

steerEl.oninput = () => {
  steerVal.textContent = (steerEl.value/100).toFixed(2);
  apply();
};

window.addEventListener("keydown", e => {
  if (e.repeat) return;
  if (e.code==="ArrowUp") up=true;
  if (e.code==="ArrowDown") down=true;
  if (e.code==="ArrowLeft") left=true;
  if (e.code==="ArrowRight") right=true;
  if (e.code==="Space") { up=down=left=right=false; send(0,0); }
  apply();
});

window.addEventListener("keyup", e => {
  if (e.code==="ArrowUp") up=false;
  if (e.code==="ArrowDown") down=false;
  if (e.code==="ArrowLeft") left=false;
  if (e.code==="ArrowRight") right=false;
  apply();
});

window.addEventListener("blur", () => {
  up=down=left=right=false;
  send(0,0);
});
